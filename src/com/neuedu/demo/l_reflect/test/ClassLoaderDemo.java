package com.neuedu.demo.l_reflect.test;

import com.neuedu.demo.l_reflect.pojo.Son;

/*
 当需要使用某个类时，虚拟机将会加载它的 .class 文件，并创建对应的 class 对象，将 class 文件加载到虚拟机的内存，这个过程称为类加载。
 类加载的过程：加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
  ● 加载：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象
  ● 验证：确保 .class 文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全（文件格式验证，元数据验证，字节码验证，符号引用验证）。
  ● 准备:为类变量（即 static 修饰的字段变量）分配内存，并且设置该类变量的初始值即0（如 static int i=5; 这里只将 i 初始化为 0，至于 5 的值将在类初始化阶段时赋值），
    这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，注意这里不会为实例变量分配初始化，
    类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。
  ● 解析：主要将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，
    而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析。
  ● 初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量（如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化）。

  类加载器（ClassLoader）是 JVM 的一个重要组成部分，它负责将 Java 类（包括接口、类、枚举等）的字节码文件加载到 JVM 中。
  类加载器的分类：
  BootStrap：启动类加载器（引导类加载器，根加载器，最顶层加载器），加载除了 ext 文件夹之外 jre-8u321\lib 文件夹下的所有类，包括核心类库（rt.jar）
  ExtClassLoader：扩展类加载器，默认加载 jre-8u321\lib\ext 下的所有类
  AppClassLoader：应用类加载器，默认加载项目中所有的类
  自定义类加载器：继承 ClassLoader 抽象类，重写 findClass 方法来定制类的加载逻辑。自定义类加载器可以用于加载加密的类文件，并在加载过程中解密它们，增加了代码的安全性。

  类加载器的委托机制：每一个类加载器都有一个父类加载器，当某个类加载器需要加载一个类时，在加载之前它会先将这个类委托给它的父类加载器，
  这个过程会一直传递，直到最顶层类加载器（也叫根加载器）。如果最顶层累加载器无法加载这个类，那么就会把这个加载请求返回给子类加载器，
  在子类加载器中，如果找到了就返回这个类的 Class 对象，如果没找到就会抛出 ClassNotFoundException 异常，表示无法加载这个类。
  委托机制的作用：
  ● 安全性：通过委托机制，Java可以确保类加载的安全性。因为所有的类加载请求都会先经过最顶层的类加载器，也就是启动类加载器，
  而启动类加载器加载的是Java的核心类库，这些类库是可信的。这样可以防止恶意代码通过自定义的类加载器来加载非法的类，从而破坏Java的运行环境。
  ● 高效性：因为类加载器会先在自己的命名空间中查找已经加载过的类，这样可以避免重复加载相同的类。同时，由于类加载器之间存在父子关系，
  当一个类被加载后，它的所有子类加载器都可以直接使用这个类，而不需要再次加载。
  ● 一致性：因为所有的类加载请求都会经过相同的加载路径，所以无论在哪个类加载器中加载同一个类，得到的Class对象都是相同的。
*/
public class ClassLoaderDemo {
    public static void main(String[] args) {
        Son son = new Son();
        // 获取对象对应的字节码文件对象
        Class<? extends Son> sonClass = son.getClass();
        // 获取当前class文件的类加载器
        ClassLoader classLoader = sonClass.getClassLoader();
        System.out.println(classLoader); // jdk.internal.loader.ClassLoaders$AppClassLoader@63947c6b

        // 获取当前类加载器的父类加载器
        ClassLoader father = classLoader.getParent();
        System.out.println(father);  // jdk.internal.loader.ClassLoaders$PlatformClassLoader@41629346

        // 获取根加载器
        ClassLoader root = father.getParent();
        System.out.println(root);  // null 不让看

        // 获取 String 类的类加载器（String 类时根加载器加载的类）
        ClassLoader stringClassLoader = String.class.getClassLoader();
        System.out.println(stringClassLoader);  // null 也不让看
    }
}
/*
  JVM 内存模型：
  ★ 堆（Heap）：堆是 JVM 所管理的内存中最大的一块，是所有线程共享的内存区域，用于存放对象实例。
     堆是垃圾收集器管理的主要区域，GC（Garbage Collection）主要在堆上执行，因此也被称为“GC堆”。

  ★ 栈（Stack）：栈是每个线程私有的内存区域，用于存储局部变量、方法调用的参数和方法返回值。
     栈的生命周期与线程一致，当线程结束时，栈也会被销毁。

  ★ 方法区（Method Area）：方法区是各个线程共享的内存区域，方法区存放的数据有：
    1. 存储类结构信息：类名、修饰符、父类信息、接口信息等。
    2. 存储方法信息：包含方法的名称、返回类型、参数信息、修饰符等。此外，还包括方法的字节码，即将Java源代码编译成可供JVM执行的字节码。
    3. 静态变量：静态变量是类级别的变量，可以被类的所有实例共享。它们在类加载时就会被存储在内存中，而不是在实例化对象时。
    4. 常量池： 分为 Class文件常量池 和 运行时常量池
        ● Class 文件常量池：Class文件常量池本身不在方法区中，存在于.class文件中。但它是形成运行时常量池的基础。运行时常量池作为方法区的一部分，在JVM运行时用于动态解析和使用这些常量。
        ● 运行时常量池：是方法区的一部分，当类加载器加载类时，会把Class文件常量池中的内容加载到JVM的方法区内存区域，形成运行时常量池，用于支持对字面量和符号引用的动态解析。
            JDK 1.6及之前：运行时常量池位于方法区（也称为永久代）中。
            JDK 1.7及之后：随着永久代的移除，运行时常量池被移至元空间（Metaspace）中。字符串常量池被移至堆内存中。
   在Java 8及之前，方法区是永久代（PermGen space）的一部分，但在Java 8及之后的版本中，永久代被元空间（Metaspace）所取代。
    ● 永久代：定义：在 Java 7 及之前的版本中，永久代是JVM内存中的一部分，专门用于存储类的元数据信息、常量池、静态变量等数据。
        特点：
        永久代的大小是固定的，可以通过JVM启动参数-XX:PermSize和-XX:MaxPermSize进行设置。
        由于永久代位于JVM内存中，因此它受到JVM总内存（由-Xms和-Xmx参数指定）的限制。
        当永久代中的类元数据过多，超过其预设的大小时，可能会引发java.lang.OutOfMemoryError: PermGen space错误。
        永久代的垃圾回收是在JVM的全局垃圾回收过程中进行的，但由于其包含的是类的元数据，因此回收效率相对较低
    ● 元空间：定义：从 Java 8 开始，永久代被元空间所取代。元空间不是JVM内存的一部分，而是使用本地内存（Native Memory），即不受JVM总内存大小限制的系统内存。
        特点：
        元空间的大小不是固定的，而是根据应用的需要动态调整。这避免了永久代中因内存不足而导致的OutOfMemoryError问题。
        元空间的内存管理是通过对类和元数据的加载、卸载和转移来实现的。当类或元数据不再被使用时，它们会被标记为可卸载状态，并等待垃圾回收器执行卸载操作。
        由于元空间使用的是本地内存，因此其内存的分配和释放不受JVM垃圾回收器的直接控制。但JVM会监控元空间的使用情况，并在必要时触发垃圾回收。
        元空间的引入提高了类加载的性能，因为类元数据的加载和卸载不再受到JVM内存大小的限制。

  ★ 程序计数器（Program Counter Register）：程序计数器是一块较小的内存空间，作为当前线程所执行的字节码的行号指示器。
     通过改变这个计数器的值来选取下一条需要执行的字节码指令。它是线程私有的，每条线程都有自己的程序计数器，互不影响。

  ★ 本地方法栈（Native Method Stack）：本地方法栈与虚拟机栈类似，但它是为虚拟机执行 Native 方法（即非Java方法，如C或C++编写的方法）服务的。
     它也是线程私有的，与虚拟机栈一样，当线程结束时，本地方法栈也会被销毁。
*/

/*
  字面量：指的是在源代码中直接表示的数据值，而不是通过变量名或表达式计算得出的值。字面量可以直接在代码中使用，
   它们被编译器或解释器直接识别为具体的值，而不需要任何计算或转换。
    ● 整数字面量：直接表示整数的值，如 123、-456。
    ● 浮点数字面量：直接表示浮点数的值，通常包含小数点或指数部分，如 3.14、1.2e3（等于1200）。
    ● 字符字面量：用单引号括起来的单个字符，如 'a'、'\n'（换行符）。在某些语言中，也可以使用特定的转义序列来表示特殊字符。
    ● 字符串字面量：用双引号或单引号（取决于语言）括起来的一系列字符，如 "Hello, world!"、'Hello, world!'（注意：不是所有语言都支持单引号字符串）。
    ● 布尔字面量：表示真或假的值，如 true、false。
    ● 空字面量：表示空值或不存在的值，如 null（在某些语言中）。
    ● 枚举字面量：在支持枚举类型的语言中，枚举的实例也可以作为字面量使用，如 Color.RED（假设Color是一个枚举类型，RED是其中的一个枚举常量）。
    ● 数组字面量：直接表示数组值的字面量，如 [1, 2, 3]（表示一个包含三个整数的数组）。
    ● 对象字面量（或称为字典、映射、哈希表等，取决于语言）：直接表示对象或键值对集合的字面量，如 {"name": "John", "age": 30}（在JavaScript中）。
*/